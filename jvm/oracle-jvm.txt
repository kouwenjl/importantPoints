1.默认内存：
  一类机器被称为服务器类机器被定义为以下机器:
  2个或更多物理处理器
  2 GB或更多的物理内存
  在服务器类机器上，默认选择以下选项:
  吞吐量垃圾收集器
  初始堆大小为物理内存的1/64，最多1 GB
  最大堆大小为物理内存的1/4，最多1 GB


2.指定日志输出位置
  
  -Xloggc:gc.log

3.打印垃圾收集详细信息
  -verbose:gc导致在每次收集时打印有关堆和垃圾收集的信息，是一种综合信息 不区分代 并且内存可用量只包含一个幸存区域的大小
  [GC (Allocation Failure)  7051K->6856K(9216K), 0.0040522 secs]
  [GC (Allocation Failure) -- 7880K->7880K(9216K), 0.0170089 secs]
  [Full GC (Ergonomics)  7880K->7779K(9216K), 0.0162592 secs]
  [GC (Allocation Failure) -- 7779K->7779K(9216K), 0.0035438 secs]
  [Full GC (Allocation Failure)  7779K->7779K(9216K), 0.0100603 secs]
  Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
        at dxs.collection.AttributeList.main(AttributeList.java:17)


  -XX:+PrintGCDetails会导致打印关于集合的附加信息 单独提出了新生代信息

  [GC (Allocation Failure) [PSYoungGen: 907K->504K(2048K)] 7051K->6808K(9216K), 0.0046139 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
  [GC (Allocation Failure) --[PSYoungGen: 1528K->1528K(2048K)] 7832K->7872K(9216K), 0.0071760 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
  [Full GC (Ergonomics) [PSYoungGen: 1528K->1472K(2048K)] [ParOldGen: 6344K->6306K(7168K)] 7872K->7779K(9216K), [Metaspace: 2635K->2635K(1056768K)], 0.0127456 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]
  [GC (Allocation Failure) --[PSYoungGen: 1472K->1472K(2048K)] 7779K->7787K(9216K), 0.0032685 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
  [Full GC (Allocation Failure) [PSYoungGen: 1472K->1472K(2048K)] [ParOldGen: 6314K->6306K(7168K)] 7787K->7779K(9216K), [Metaspace: 2635K->2635K(1056768K)], 0.0138369 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]
  Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
        at dxs.collection.AttributeList.main(AttributeList.java:17)
  Heap
   PSYoungGen      total 2048K, used 1518K [0x00000000ffd00000, 0x00000000fff80000, 0x0000000100000000)
    eden space 1536K, 98% used [0x00000000ffd00000,0x00000000ffe7ba60,0x00000000ffe80000)
    from space 512K, 0% used [0x00000000ffe80000,0x00000000ffe80000,0x00000000fff00000)
    to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)
  ParOldGen       total 7168K, used 6306K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)
    object space 7168K, 87% used [0x00000000ff600000,0x00000000ffc28ba0,0x00000000ffd00000)
  Metaspace       used 2666K, capacity 4486K, committed 4864K, reserved 1056768K
    class space    used 283K, capacity 386K, committed 512K, reserved 1048576K

 -XX:+PrintGCTimeStamps 在每个集合的开始处添加一个时间戳
  Java HotSpot(TM) 64-Bit Server VM (25.251-b08) for windows-amd64 JRE (1.8.0_251-b08), built on Mar 12 2020 06:31:49 by "" with MS VC++ 10.0 (VS2010)
  Memory: 4k page, physical 8247820k(2128600k free), swap 16493740k(8051468k free)
  CommandLine flags: -XX:InitialHeapSize=8388608 -XX:MaxHeapSize=10485760 -XX:+PrintGC -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC 
  35.124: [GC (Allocation Failure)  7051K->6792K(9216K), 0.0021425 secs]
  40.126: [GC (Allocation Failure) -- 7816K->7848K(9216K), 0.0019433 secs]
  40.128: [Full GC (Ergonomics)  7848K->7779K(9216K), 0.0101982 secs]
  40.138: [GC (Allocation Failure) -- 7779K->7803K(9216K), 0.0016668 secs]
  40.140: [Full GC (Allocation Failure)  7803K->7779K(9216K), 0.0106662 secs]

4.代大小
 -Xms 初始堆
 -Xmx 最大堆
 -XX:NewRatio 年轻代与年老代的比率
 -XX:MinHeapFreeRatio  堆的最小空闲比率
 -XX:MaxHeapFreeRatio  堆的最大空闲比率
 -XX:+PrintTenuringDistribution 显示年轻代的对象在经历了多少次的收集后可以转为年老代
 -XX:NewSize 新生代大小 优先于比例
 -XX:MaxNewSize 最大的新生代大小
 -XX:SurvivorRatio 幸存区域比例大小

5 .启用垃圾收集器
  -XX:+UseSerialGC 启用串行的垃圾收集器
  -XX:+UseParallelGC 启用并行的垃圾收集器 可以进行并行压缩 处理器核数 大于8 则默认为5/8 个并行线程 等于核数
      -XX:ParallelGCThreads 指定并行垃圾收集线程数量
      由于多个垃圾收集器线程参与了一次小的收集，因此在收集期间从年轻代提升到成熟代可能会产生一些碎片。
      小收集中涉及的每个垃圾收集线程都会为升级保留一部分保留期生成，而将可用空间划分为这些“升级缓冲区”可能会导致碎片效应。
      减少垃圾收集器线程的数量和增加年老代的大小将减少这种碎片效应。
      -XX:MaxGCPauseMillis 最大暂停时间
      如果指定了暂停时间目标，则将调整堆大小和与垃圾收集相关的其他参数，
      试图使垃圾收集暂停时间小于指定的值。这些调整可能会导致垃圾收集器降低应用程序的总体吞吐量，并不能总是满足所需的暂停时间目标。
      -XX:GCTimeRatio 吞吐量 执行垃圾收集与应用程序执行时间的比值
     注意：收集器有一个隐式的目标，即在满足其他目标的情况下最小化堆的大小。
         优先考虑的目标
         这些目标的实现顺序如下:
         最大暂停时间目标
         吞吐量目标
         最小排放目标
         首先达到最大暂停时间目标。只有在满足这个要求之后，才能实现吞吐量目标。类似地，只有在前两个目标得到满足之后才会考虑内存占用目标。
      -XX:YoungGenerationSizeIncrement =X年轻代增量百分比
      -XX:TenuredGenerationSizeIncrement =X年老代增量百分比
      -XX:AdaptiveSizeDecrementScaleFactor=D缩量因子
      注意:如果增长的增量是X %，那么收缩的递减量是X/D %。 默认增量20%，缩量为5%
          如果收集器决定在启动时增加代，则会在增量中添加一个补充百分比。这种补充随收集次数的增加而减少，没有长期效果。这个补充的目的是提高启动性能。对于萎缩的百分比没有补充。
          如果最大暂停时间目标没有被满足，那么每次只缩小一个代的大小。如果两代的暂停时间都高于目标，那么暂停时间较大的代的大小首先会缩小。
          如果吞吐量目标没有被满足，两个代的大小都会增加。它们各自占总垃圾收集时间的比例增加。例如，如果年轻代的垃圾收集时间是总收集时间的25%，如果年轻代的全部增量是20%，那么年轻代将增加5%。
  -XX:-UseParallelOldGC 关闭并行压缩
  -XX:+UseConcMarkSweepGC cms并发收集
    并发模式失败
    CMS收集器使用一个或多个与应用程序线程同时运行的垃圾收集器线程，其目标是在保留区生成满之前完成它的收集。
    如前所述，在正常操作中，CMS收集器在应用程序线程仍在运行的情况下执行大部分跟踪和清理工作，因此应用程序线程只能看到短暂的暂停。
    然而,如果CMS收集器无法完成回收终身一代填满前不可到达的对象,或者如果一个分配不能满意终身的免费空间块生成,然后应用程序暂停收集完成所有应用程序线程停止了。
    不能并发地完成收集被称为并发模式失败，这表明需要调整CMS收集器参数。如果显式垃圾收集(System.gc())中断了并发收集，或者中断了需要为诊断工具提供信息的垃圾收集，则报告并发模式中断。
    漂浮的垃圾
    由于应用程序线程和垃圾收集器线程在一次主要收集期间并发运行，因此垃圾收集器线程跟踪的对象可能在收集过程结束时变得不可访问。这种还没有被回收的不可到达的对象称为浮动垃圾。
    何时启动
    并发收集的开始必须有时间限制，这样收集可以在保留区生成满之前完成;否则，由于并发模式失败，应用程序将观察到更长时间的暂停。有几种方法可以启动并发收集。
    根据最近的历史，CMS收集器会估计使用终身代用完之前剩余的时间，以及并发收集周期所需的时间。使用这些动态估计，将启动一个并发收集周期，目的是在使用终身生成之前完成收集周期。
    由于并发模式失败的代价可能非常高，所以为了安全起见，这些估计是多余的。
    如果保留区生成的占用超过初始占用(保留区生成的百分比)，也会启动并发收集。这个初始占用阈值的默认值大约是92%，
    但是这个值会随着版本的不同而变化。可以使用命令行选项-XX:CMSInitiatingOccupancyFraction=<N>手动调整该值，其中<N>是终身生成大小的整数百分比(0到100)。
    -XX:CMSInitiatingOccupancyFraction=<N>
    调度停顿
    年轻代收集和长期代收集的暂停独立发生。它们不重叠，但可能会快速连续地发生，因此从一个集合开始的暂停，紧接着从另一个集合开始的暂停，可以看起来是一个单独的、较长的暂停。
    为了避免这种情况，CMS收集器尝试将注释暂停安排在上一个和下一年轻代的暂停之间。这种调度目前还没有对初始标记pause执行，它通常比注释pause短得多。https://blog.csdn.net/enemyisgodlike/article/details/106960687
    增量模式
    注意，增量模式在Java SE 8中已被弃用，可能会在将来的主要版本中被删除。
    CMS收集器可以在增量地完成并发阶段的模式中使用。回想一下，在并发阶段，垃圾收集器线程使用一个或多个处理器。
    增量模式旨在通过周期性地停止并发阶段以将处理器交还给应用程序来减少长并发阶段的影响。这种模式在这里称为i-cms，它将收集器并发完成的工作划分为小块时间，
    在年轻代收集之间调度这些小块时间。当需要CMS收集器提供的低暂停时间的应用程序运行在具有少量处理器(例如1或2个)的机器上时，该特性非常有用。
    并发收集周期通常包括以下步骤:
    停止所有应用程序线程，标识从根可访问的对象集，然后恢复所有应用程序线程。
    当应用程序线程执行时，使用一个或多个处理器并发地跟踪可到达的对象图。
    使用一个处理器，并发地回溯自上一步跟踪以来被修改的对象图部分。
    停止所有应用程序线程，并重新跟踪根和对象图中自上次检查以来可能被修改的部分，然后恢复所有应用程序线程。
    使用一个处理器，并发地将不可访问的对象清除到用于分配的空闲列表中。
    使用一个处理器，并发地调整堆大小并为下一个收集周期准备支持数据结构。
  -XX:+UseG1GC G1并发收集器
    垃圾优先(G1)垃圾收集器是一种服务器风格的垃圾收集器，针对具有大内存的多处理器机器。它尝试以高概率满足垃圾收集(GC)暂停时间目标，同时实现高吞吐量。
    整堆操作(例如全局标记)与应用程序线程并发执行。这可以防止中断与堆或实时数据大小成比例。
    G1收集器通过多种技术实现了高性能和暂停时间目标。
    堆被划分为一组大小相同的堆区域，每个区域都是连续的虚拟内存范围。G1执行一个并发全局标记阶段，以确定堆中对象的活性。标记阶段完成后，
    G1知道哪些区域大部分是空的。它首先收集这些区域，这通常会产生大量的空闲空间。这就是为什么这种垃圾收集方法被称为垃圾优先的原因。顾名思义，
    G1将其收集和压缩活动集中在堆中可能充满可回收对象(即垃圾)的区域。G1使用一个暂停预测模型来满足用户定义的暂停时间目标，并根据指定的暂停时间目标选择要收集的区域数。
    G1将对象从堆的一个或多个区域复制到堆上的单个区域，并在这个过程中压缩和释放内存。此疏散在多处理器上并行执行，以减少暂停时间并提高吞吐量。
    因此，对于每一次垃圾收集，G1都持续工作以减少碎片。这超出了前面两种方法的能力。CMS(并发标记清除)垃圾收集不执行压缩。并行压缩只执行整堆压缩，这会导致相当长的暂停时间。
    需要注意的是，G1不是一个实时收集器。它满足设定的暂停时间目标的概率很高，但不是绝对确定的。基于以前收集的数据，G1估计在目标时间内可以收集多少区域。
    因此，收集器对于收集区域的成本有一个相当准确的模型，它使用这个模型来确定要收集哪些区域和多少区域，同时保持在暂停时间目标内。
    G1的第一个重点是为运行需要大堆且GC延迟有限的应用程序的用户提供解决方案。这意味着堆大小大约为6 GB或更大，并且稳定且可预测的暂停时间低于0.5秒。
    如果应用程序具有以下一个或多个特性，那么现在运行的CMS或并行压缩的应用程序都可以从切换到G1中获益。
    超过50%的Java堆被实时数据占用。
    对象分配率或提升率差异很大。
    应用程序正在经历不希望的长时间垃圾收集或压缩暂停(超过0.5到1秒)。
    G1计划作为并发标记-清除收集器(CMS)的长期替代品。对比G1和CMS, G1是更好的解决方案。一个不同之处在于G1是一个压缩收集器。此外，G1比CMS收集器提供了更多可预测的垃圾收集暂停，
    并允许用户指定所需的暂停目标。

    分配(疏散)失败
    与CMS一样，G1收集器在应用程序继续运行时运行它的部分收集，存在应用程序分配对象的速度比垃圾收集器恢复空闲空间的速度快的风险。
    有关类似的CMS行为，请参阅并发标记清除(CMS)收集器中的并发模式失败一节。在G1中，当G1将实时数据从一个区域复制(撤离)到另一个区域时，
    会发生故障(Java堆耗尽)。复制是为了压缩实时数据。如果在垃圾收集区域的疏散过程中找不到空闲(空)区域，则会发生分配失败(因为从被疏散的区域中没有空间分配活动对象)，
    并完成stop-the-world (STW)全收集。

    漂浮的垃圾
    对象可能在G1收集期间死亡而不被收集。G1使用一种名为“开始快照”(snapshot-at-the- first (SATB))的技术来保证所有活动对象都被垃圾收集器找到。
    SATB规定，在并发标记开始时(在整个堆上进行标记)活动的任何对象都被认为是活动的，以便进行收集。SATB允许浮动垃圾，其方式类似于CMS增量更新。

    开始一个并发收集周期
    如前所述，年轻和年老区域都在混合收集中进行垃圾收集。为了收集旧区域，G1对堆中的活动对象进行完整标记。这种标记由并发标记阶段完成。当整个Java堆的占用量达到参数InitiatingHeapOccupancyPercent时，
    将启动并发标记阶段。使用命令行选项-XX: InitiatingHeapOccupancyPercent =<NN>设置该参数的值 默认值是45。
    -XX:InitiatingHeapOccupancyPercent 45 默认

    暂停时间目标
    使用标志MaxGCPauseMillis为G1设置暂停时间目标。G1使用一个预测模型来决定在目标暂停时间内可以完成多少垃圾收集工作。在一个集合结束时，G1选择下一个集合(集合集)中要收集的区域。
    集合集将包含年轻区域(其大小的总和决定了逻辑年轻代的大小)。在一定程度上，G1通过选择收集集中的年轻区域的数量来控制GC暂停的长度。
    您可以像使用其他垃圾收集器一样在命令行上指定年轻代的大小，但是这样做可能会妨碍G1获得目标暂停时间。除了暂停时间目标之外，您还可以指定可以发生暂停的时间段的长度。
    您可以在此时间跨度(GCPauseIntervalMillis)和暂停时间目标中指定最小的mutator使用。MaxGCPauseMillis的默认值是200毫秒。GCPauseIntervalMillis的默认值(0)相当于对时间跨度没有要求。
    -XX:MaxGCPauseMillis


    G1 GC调整其年轻代(eden和幸存者大小)以满足软实时目标
    在混合收集期间，G1 GC根据混合垃圾收集的目标数量、堆中每个区域的活动对象的百分比和总体可接受的堆浪费百分比调整收集的旧区域的数量。

    标记周期的各个阶段
    打标周期有以下几个阶段:
    初始标记阶段:G1 GC在此阶段标记根。这个阶段依赖于一个正常(STW)年轻的垃圾收集。
    根区域扫描阶段:G1 GC扫描在初始标记阶段标记的对旧代的引用的幸存者区域，并标记被引用的对象。此阶段与应用程序(不是STW)并发运行，并且必须在下一次STW年轻垃圾收集开始之前完成。
    并发标记阶段:G1 GC在整个堆中找到可到达的(活的)对象。此阶段与应用程序同时发生，可以被STW年轻垃圾收集中断。
    备注阶段:此阶段为STW收集，帮助完成标刻周期。G1 GC消耗SATB缓冲区，跟踪未访问的活动对象，并执行引用处理。
    清理阶段:在最后一个阶段，G1 GC执行会计和资源集清理的STW操作。在计算期间，G1 GC识别完全空闲区域和混合垃圾收集候选区域。当清理阶段重新设置空区域并将其返回到空闲列表时，它部分是并发的。

    -XX:G1HeapRegionSize=n 设置G1区域的大小。这个值将是2的幂次，范围从1 MB到32 MB，目标是基于最小Java堆大小有大约2048个区域。
    -XX:G1NewSizePercent=5 设置要使用的堆的百分比作为年轻代大小的最小值。默认值是Java堆. foot1的5%
                           这是一面实验旗帜。以如何解锁实验性VM标志为例。此设置将替换-XX:DefaultMinNewGenPercent设置。
    -XX:G1MaxNewSizePercent=60
    -XX:ParallelGCThreads=n 设置STW工作线程的值。将值n设置为逻辑处理器的数量。n的值与逻辑处理器的数量相同，最大值为8。
                            如果有超过8个逻辑处理器，则将n的值设置为大约5/8个逻辑处理器。这在大多数情况下都可以工作，除了较大的SPARC系统，其中n的值大约是逻辑处理器的5/16。
    -XX:ConcGCThreads=n 设置并行标记线程的数量。将n设置为并行垃圾收集线程(ParallelGCThreads)的大约1/4。
    -XX:InitiatingHeapOccupancyPercent=45  设置触发标记周期的Java堆占用阈值。默认占用整个Java堆的45%。
    -XX:G1MixedGCLiveThresholdPercent=85 设置要包含在混合垃圾收集周期中的旧区域的占用阈值。默认入住率是85%
                                         这是一面实验旗帜。以如何解锁实验性VM标志为例。此设置将替换-XX:G1OldCSetRegionLiveThresholdPercent设置。
    -XX:G1HeapWastePercent=5 设置您愿意浪费的堆的百分比。当可回收百分比小于堆浪费百分比时，Java HotSpot VM不会启动混合垃圾收集周期。默认值是5% . footref1
    -XX:G1MixedGCCountTarget=8 设置标记周期后混合垃圾收集的目标数量，以收集最多G1MixedGCLIveThresholdPercent活动数据的旧区域。默认值是8个混合垃圾收集。混合集合的目标是在这个目标数字. footref1之内
    -XX:G1OldCSetRegionThresholdPercent=10  设置混合垃圾收集周期中要收集的旧区域数量的上限。默认值是Java堆. footref1的10%
    -XX:G1ReservePercent=10 设置保留内存的百分比以保持空闲，以降低空间溢出的风险。默认是10%当您增加或减少百分比时，请确保按相同的金额调整整个Java堆

    当你评估和调整G1 GC时，请记住以下建议:
    年轻代大小:避免使用-Xmn选项或任何或其他相关选项(如-XX:NewRatio)显式设置年轻代大小。确定年轻一代的大小会覆盖目标暂停时间目标。

    巨大的物体和巨大的分配
    对于G1 GC，任何大于一半区域大小的对象都被认为是巨型对象。这样的对象在旧代中直接分配到巨大的区域中。这些巨大的区域是一组相邻的区域。StartsHumongous标志连续集合的开始，ContinuesHumongous标志连续集合的继续。
    在分配任何巨大区域之前，检查标记阈值，如果需要，启动一个并发循环。
    在标记周期结束时，在清理阶段以及在完整的垃圾收集周期中释放死的巨量对象。
    为了减少复制开销，在任何疏散暂停中都不包括这些巨大的对象。一个完整的垃圾收集周期会将巨大的对象压缩到适当的位置。
    因为每一组起始和连续的巨型区域都只包含一个巨型对象，所以巨型对象结束和该对象跨越的最后一个区域结束之间的空间是未使用的。对于只比堆区域大小的倍数稍大一点的对象，这个未使用的空间可能会导致堆碎片化。
    如果您看到由于大量分配而启动了连续的并发循环，并且这种分配正在分割您的旧代，那么增加-XX:G1HeapRegionSize的值，使以前的大量对象不再是大量的，并将遵循常规的分配路径。

6.
-XX:+PrintFlagsFinal 打印控制信息
-XX:-UseAdaptiveSizePolicy
-XX:+UseAdaptiveSizePolicy 自适应策略 将使-XX:SurvivorRatio  无效
-XX:-UseGCOverheadLimit
 如果太多时间花在垃圾收集(GC)上，并行收集器会抛出OutOfMemoryError:如果超过98%的时间花在垃圾收集上，而只有不到2%的堆被恢复，那么就会抛出OutOfMemoryError。该特性旨在防止由于堆太小而导致应用程序运行较长时间而几乎没有进展。如果有必要，可以通过在命令行中添加选项-XX:-UseGCOverheadLimit来禁用此功能。
 测量